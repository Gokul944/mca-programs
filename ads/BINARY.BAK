#include <stdio.h>
#include <stdlib.h> // Changed alloc.h to stdlib.h for malloc
#include <conio.h>  // Include conio.h for getch()

struct TreeNode {
    struct TreeNode* Ichild; // Left child
    int data;
    struct TreeNode* rchild; // Right child
};
typedef struct TreeNode TreeNode;

TreeNode* getNode();
void TreeInsert(TreeNode** rt, int item);
void Inorder(TreeNode* rt);
void Preorder(TreeNode* rt);
void Postorder(TreeNode* rt);
void TreeDisplay(TreeNode* rt, int level);
void TreeDelete(TreeNode** rt, int item);

int main() {
    int a[100], i, n, item;
    TreeNode* root = NULL;

    printf("\nEnter number of elements in data list: ");
    scanf("%d", &n);
    
    printf("Enter the elements: ");
    for (i = 0; i < n; i++) {
        scanf("%d", &a[i]);
        TreeInsert(&root, a[i]);
    }

    printf("\nBinary tree:\n");
    TreeDisplay(root, 1);
    
    printf("\nInorder Traverse:\n");
    Inorder(root);
    
    printf("\nPreorder Traverse:\n");
    Preorder(root);
    
    printf("\nPostorder Traverse:\n");
    Postorder(root);
    
    printf("\nEnter the item to be deleted: ");
    scanf("%d", &item);
    TreeDelete(&root, item);
    
    printf("\nBinary tree after deletion:\n");
    TreeDisplay(root, 1);
    
    getch(); // Wait for a key press
    return 0; // Proper return type for main
}

TreeNode* getNode() {
    TreeNode* t = (TreeNode*)malloc(sizeof(TreeNode));
    if (t != NULL) {
        t->Ichild = NULL;
        t->rchild = NULL;
    }
    return t;
}

void TreeInsert(TreeNode** rt, int item) {
    TreeNode* current = *rt;
    TreeNode* temp;

    if (*rt == NULL) {
        *rt = getNode();
        (*rt)->data = item;
        return;
    }

    while (1) {
        if (item < current->data) {
            if (current->Ichild == NULL) {
                temp = getNode();
                temp->data = item;
                current->Ichild = temp;
                return;
            }
            current = current->Ichild;
        } else if (item > current->data) {
            if (current->rchild == NULL) {
                temp = getNode();
                temp->data = item;
                current->rchild = temp;
                return;
            }
            current = current->rchild;
        } else {
            printf("Duplicate value not allowed.\n");
            return; // Item already exists
        }
    }
}

void Inorder(TreeNode* rt) {
    if (rt != NULL) {
        Inorder(rt->Ichild);
        printf("%4d", rt->data);
        Inorder(rt->rchild);
    }
}

void Preorder(TreeNode* rt) {
    if (rt != NULL) {
        printf("%4d", rt->data);
        Preorder(rt->Ichild);
        Preorder(rt->rchild);
    }
}

void Postorder(TreeNode* rt) {
    if (rt != NULL) {
        Postorder(rt->Ichild);
        Postorder(rt->rchild);
        printf("%4d", rt->data);
    }
}

void TreeDisplay(TreeNode* rt, int level) {
    int i;
    if (rt != NULL) {
	TreeDisplay(rt->rchild, level + 1);
	printf("\n");
	for(i = 0; i < level; i++) {
            printf(" ");
        }
        printf("%d", rt->data);
        TreeDisplay(rt->Ichild, level + 1);
    }
}

void TreeDelete(TreeNode** rt, int item) {
    TreeNode* current;
    if (*rt == NULL) {
        printf("Error: Item not found\n");
        return;
    }
    if (item < (*rt)->data) {
        TreeDelete(&((*rt)->Ichild), item);
    } else if (item > (*rt)->data) {
        TreeDelete(&((*rt)->rchild), item);
    } else {
        current = *rt;
        if (current->Ichild == NULL) {
            *rt = current->rchild;
            free(current);
        } else if (current->rchild == NULL) {
            *rt = current->Ichild;
            free(current);
        } else {
            TreeNode* temp = current->rchild;
            while (temp->Ichild != NULL) {
                temp = temp->Ichild;
            }
            current->data = temp->data;
            TreeDelete(&(current->rchild), temp->data);
        }
    }
}
